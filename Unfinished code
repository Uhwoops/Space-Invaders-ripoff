import SwiftUI
import CoreGraphics



struct Player {
    var position: CGPoint
}

struct Enemy: Identifiable {
    let id = UUID()
    let type: String = "enemy"
    var position: CGPoint
}

struct Bullet: Identifiable {
    let id = UUID()
    var position: CGPoint
}

struct EnemyBullet: Identifiable {
    let id = UUID()
    var position: CGPoint
}



class GameViewModel: ObservableObject {

    @Published var player = Player(position: CGPoint(x: 200, y: 80))
    @Published var bullets: [Bullet] = []
    @Published var enemies: [Enemy] = []
    @Published var enemyBullets: [EnemyBullet] = []

    private var enemyDirection: CGFloat = 1

    init() {
        createEnemies()
    }

    func createEnemies() {
        enemies = []
        for row in 0..<4 {
            for col in 0..<6 {
                enemies.append(
                    Enemy(position: CGPoint(
                        x: 80 + CGFloat(col) * 50,
                        y: 500 - CGFloat(row) * 40
                    ))
                )
            }
        }
    }

    func movePlayerLeft() {
        player.position.x -= 15
    }

    func movePlayerRight() {
        player.position.x += 15
    }

    func shoot() {
        bullets.append(
            Bullet(position: CGPoint(
                x: player.position.x,
                y: player.position.y + 30
            ))
        )
    }

    func updateBullets() {
        for i in bullets.indices {
            bullets[i].position.y += 10
        }
        bullets.removeAll { $0.position.y > 800 }
    }

    func updateEnemyBullets() {
        for i in enemyBullets.indices {
            enemyBullets[i].position.y -= 8
        }
        enemyBullets.removeAll { $0.position.y < 0 }
    }

    func updateEnemies() {
        for i in enemies.indices {
            enemies[i].position.x += enemyDirection * 2
        }

        if enemies.contains(where: { $0.position.x < 20 || $0.position.x > 380 }) {
            enemyDirection *= -1
            for i in enemies.indices {
                enemies[i].position.y -= 20
            }
        }
    }

    func enemyShoot() {
        for enemy in enemies {
            if Int.random(in: 0...120) == 1 {
                enemyBullets.append(
                    EnemyBullet(position: CGPoint(
                        x: enemy.position.x,
                        y: enemy.position.y - 20
                    ))
                )
            }
        }
    }

    func handleCollisions() {
        bullets.removeAll { bullet in
            enemies.contains { enemy in
                abs(bullet.position.x - enemy.position.x) < 20 &&
                abs(bullet.position.y - enemy.position.y) < 20
            }
        }

        enemies.removeAll { enemy in
            bullets.contains { bullet in
                abs(bullet.position.x - enemy.position.x) < 20 &&
                abs(bullet.position.y - enemy.position.y) < 20
            }
        }

        enemyBullets.removeAll { bullet in
            abs(bullet.position.x - player.position.x) < 20 &&
            abs(bullet.position.y - player.position.y) < 20
        }
    }
}



struct GameView: View {
    @StateObject private var viewModel = GameViewModel()

    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()

            ForEach(viewModel.enemies) { enemy in
                Rectangle()
                    .fill(Color.red)
                    .frame(width: 40, height: 30)
                    .position(enemy.position)
            }

            Rectangle()
                .fill(Color.blue)
                .frame(width: 40, height: 20)
                .position(viewModel.player.position)

            ForEach(viewModel.bullets) { bullet in
                Rectangle()
                    .fill(Color.green)
                    .frame(width: 4, height: 10)
                    .position(bullet.position)
            }

            ForEach(viewModel.enemyBullets) { bullet in
                Rectangle()
                    .fill(Color.orange)
                    .frame(width: 4, height: 10)
                    .position(bullet.position)
            }
        }
        .onReceive(Timer.publish(every: 0.016, on: .main, in: .common).autoconnect()) { _ in
            viewModel.updateBullets()
            viewModel.updateEnemyBullets()
            viewModel.updateEnemies()
            viewModel.enemyShoot()
            viewModel.handleCollisions()
        }
        .focusable()
        .onKeyPress { key in
            switch key {
            case .leftArrow:
                viewModel.movePlayerLeft()
            case .rightArrow:
                viewModel.movePlayerRight()
            case .space:
                viewModel.shoot()
            default:
                break
            }
            return .handled
        }
    }
}



@main
struct SpacefightersApp: App {
    var body: some Scene {
        WindowGroup {
            GameView()
        }
    }
}
